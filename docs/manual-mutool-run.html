<!DOCTYPE html>
<html>
<head>
<title>mutool run</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>

<header>
<h1>mutool run</h1>
</header>

<article>

<p>
The 'mutool run' command executes a JavaScript program, which has access to most of the features of the MuPDF library.
The command supports ECMAScript 5 syntax in strict mode.
All of the MuPDF constructors and functions live in the global object, and the
command line arguments are accessible from the global 'scriptArgs' object.
The name of the script is in the global 'scriptPath' variable.

<pre>
mutool run script.js [ arguments ... ]
</pre>

<p>
If invoked without any arguments, it will drop you into an interactive REPL (read-eval-print-loop).

<h2>
Example scripts
</h2>

<p>
Create and edit PDF documents:

<ul>
<li><a href="examples/pdf-create-lowlevel.js">pdf-create-lowlevel.js</a>: Create PDF document from scratch using only low level functions.
<li><a href="examples/pdf-create.js">pdf-create.js</a>: Create PDF document from scratch, using helper functions.
<li><a href="examples/pdf-merge.js">pdf-merge.js</a>: Merge pages from multiple PDF documents into one PDF file.
</ul>

<p>
Graphics and the device interface:

<ul>
<li><a href="examples/draw-document.js">draw-document.js</a>: Draw all pages in a document to PNG files.
<li><a href="examples/draw-device.js">draw-device.js</a>: Use device API to draw graphics and save as a PNG file.
<li><a href="examples/trace-device.js">trace-device.js</a>: Implement a device in JavaScript.
</ul>

<p>
Advanced examples:

<ul>
<li><a href="examples/create-thumbnail.js">create-thumbnail.js</a>: Create a PDF from rendered page thumbnails.
</ul>

<h2>
JavaScript Shell
</h2>

<p>
Several global functions that are common for command line shells are available:

<dl>
<dt>gc(report)
<dd>Run the garbage collector to free up memory. Optionally report statistics on the garbage collection.
<dt>load(fileName)
<dd>Load and execute script in 'fileName'.
<dt>print(...)
<dd>Print arguments to stdout, separated by spaces and followed by a newline.
<dt>quit()
<dd>Exit the shell.
<dt>read(fileName)
<dd>Read the contents of a file and return them as a UTF-8 decoded string.
<dt>readline()
<dd>Read one line of input from stdin and return it as a string.
<dt>require(module)
<dd>Load a JavaScript module.
<dt>write(...)
<dd>Print arguments to stdout, separated by spaces.
<dt>repr(object)
<dd>Format the object into a string with javascript syntax.
</dl>

<h2>
Buffer
</h2>

<p>
The Buffer objects are used for working with binary data.
They can be used much like arrays, but are much more efficient since they
only store bytes.

<dl>
<dt>new Buffer()
<dd>Create a new empty buffer.
<dt>new Buffer(original)
<dd>Create a new buffer with a copy of the data from the original buffer.
<dt>readFile(fileName)
<dd>Create a new buffer with the contents of a file.
<dt>Buffer#length
<dd>The number of bytes in the buffer.
<dt>Buffer#[n]
<dd>Read/write the byte at index 'n'. Will throw exceptions on out of bounds accesses.
<dt>Buffer#writeByte(b)
<dd>Append a single byte to the end of the buffer.
<dt>Buffer#writeRune(c)
<dd>Encode a unicode character as UTF-8 and append to the end of the buffer.
<dt>Buffer#writeLine(...)
<dd>Append arguments to the end of the buffer, separated by spaces, ending with a newline.
<dt>Buffer#write(...)
<dd>Append arguments to the end of the buffer, separated by spaces.
<dt>Buffer#writeBuffer(data)
<dd>Append the contents of the 'data' buffer to the end of the buffer.
<dt>Buffer#slice(start, end)
<dd>Create a new Buffer containing a (subset of) the data in this buffer. Start and end are offsets from the beginning of this buffer, and if negative from the end of this buffer.
<dt>Buffer#save(fileName)
<dd>Write the contents of the buffer to a file.
</dl>

<h2>
Matrices and Rectangles
</h2>

<p>
All dimensions are in points unless otherwise specified.

<p>
Matrices are simply 6-element arrays representing a 3-by-3 transformation matrix as

<pre>
/ a b 0 \
| c d 0 |
\ e f 1 /
</pre>

<p>
This matrix is represented in JavaScript as <code>[a,b,c,d,e,f]</code>.

<dl>
<dt>Identity
<dd>The identity matrix, short hand for <code>[1,0,0,1,0,0]</code>.
<dt>Scale(sx, sy)
<dd>Return a scaling matrix, short hand for <code>[sx,0,0,sy,0,0]</code>.
<dt>Translate(tx, ty)
<dd>Return a translation matrix, short hand for <code>[1,0,0,1,tx,ty]</code>.
<dt>Rotate(theta)
<dd>Return a rotation matrix, short hand for <code>[cos(theta),sin(theta),-sin(theta),cos(theta),0,0]</code>.
<dt>Concat(a, b)
<dd>Concatenate matrices a and b. Bear in mind that matrix multiplication is not commutative.
</dl>

<p>
Rectangles are 4-element arrays, specifying the minimum and maximum corners (typically
upper left and lower right, in a coordinate space with the origin at the top left with
descending y): <code>[ulx,uly,lrx,lry]</code>.

<p>
If the minimum x coordinate is bigger than the maximum x coordinate, MuPDF treats the rectangle
as infinite in size.

<h2>
Document and Page
</h2>

<p>
MuPDF can open many document types (PDF, XPS, CBZ, EPUB, FB2 and a handful of image formats).

<dl>
<dt>new Document(fileName)
<dd>Open the named document.
<dt>Document#needsPassword()
<dd>Returns true if a password is required to open this password protected PDF.
<dt>Document#authenticatePassword(password)
<dd>Returns true if the password matches.
<dt>Document#hasPermission(permission)
<dd>Returns true if the document has permission for "print", "annotate", "edit" or "copy".
<dt>Document#getMetaData(key)
<dd>Return various meta data information. The common keys are: "format", "encryption", "info:Author", and "info:Title".
<dt>Document#setMetaData(key, value)
<dd>Set document meta data information field to a new value.
<dt>Document#isReflowable()
<dd>Returns true if the document is reflowable, such as EPUB, FB2 or XHTML.
<dt>Document#layout(pageWidth, pageHeight, fontSize)
<dd>Layout a reflowable document (EPUB, FB2, or XHTML) to fit the specified page and font size.
<dt>Document#countPages()
<dd>Count the number of pages in the document. This may change if you call the layout function with different parameters.
<dt>Document#loadPage(number)
<dd>Returns a Page object for the given page number. Page number zero (0) is the first page in the document.
<dt>Document#loadOutline()
<dd>Returns an array with the outline (table of contents).
In the array is an object for each heading with the property 'title', and a property 'page' containing the page number.
If the object has a 'down' property, it contains an array with all the sub-headings for that entry.
<dt>Document#resolveLink(uri)
<dd>Resolve a document internal link uri to a link destination.
<dt>Document#formatLinkURI(linkDestination)
<dd>Format a document internal link destination object to an URI string suitable for Page#createLink().
<dt>Document#outlineIterator()
<dd>Return an OutlineIterator for the document outline.
<dt>Document#isPDF()
<dd>Returns true if the document is a PDF document.
</dl>

<dl>
<dt>setUserCSS(userStylesheet, usePublisherStyles)
<dd>Set user styles and whether to use publisher styles when laying out reflowable documents.
</dl>

<p>
A link is a dictionary with keys for:
<dl>
<dt>Link.bounds:
<dd>A rectangle describing the link's location on the page.
<dt>Link.uri:
<dd>A uri describing either a document internal destination or a URL for a web page.
</dl>
</p>

<p>
A link destination points to a location within a document and how a document viewer should show that destination.
It consists of a dictionary with keys for:
<dl>
<dt>LinkDestination.chapter, .page:
<dd>The chapter and page within the document.
<dt>LinkDestination.type:
<dd>Either "Fit", "FitB", "FitH", "FitBH", "FitV", "FitBV", "FitR" or "XYZ", controlling which of the keys below exist.
<dt>LinkDestination.x:
<dd>The left coordinate, valid for FitV, FitBV, FitR and XYZ.
<dt>LinkDestination.y:
<dd>The top coordinate, valid for FitH, FitBH, FitR and XYZ.
<dt>LinkDestination.width:
<dd>The width of the zoomed in region, valid for XYZ.
<dt>LinkDestination.height:
<dd>The height of the zoomed in region, valid for XYZ.
<dt>LinkDestination.zoom:
<dd>The zoom factor, valid for "XYZ".
</dl>
</p>

<dl>
<dt>Page#bound()
<dd>Returns a rectangle containing the page dimensions.
<dt>Page#run(device, transform, skipAnnotations)
<dd>Calls device functions for all the contents on the page, using the specified transform matrix.
The device can be one of the built-in devices or a JavaScript object with methods for the device calls.
The transform maps from user space points to device space pixels.
If skipAnnotations is true, ignore annotations.
<dt>Page#toPixmap(transform, colorspace, alpha, skipAnnotations)
<dd>Render the page into a Pixmap, using the transform and colorspace.
If alpha is true, the page will be drawn on a transparent background, otherwise white.
<dt>Page#toDisplayList(skipAnnotations)
<dd>Record the contents on the page into a DisplayList.
<dt>Page#toStructuredText(options)
<dd>Extract the text on the page into a StructuredText object.
The options argument is a comma separated list of flags: preserve-ligatures, preserve-whitespace, preserve-spans, and preserve-images.
<dt>Page#search(needle)
<dd>Search for 'needle' text on the page, and return an array with rectangles of all matches found.
<dt>Page#getLinks()
<dd>Return an array of all the links on the page.
Each link is an object with a 'bounds' property, and either a 'page' or 'uri' property,
depending on whether it's an internal or external link.
<dt>Page#createLink(rect, destinationUri)
<dd>Create a new link within the rectangle on the page, linking to the destination URI string.
<dt>Page#deleteLink(link)
<dd>Delete the link from the page.
<dt>Page#getLabel()
<dd>Returns the page number as a string using the numbering scheme of the document.
<dt>Page#isPDF()
<dd>Returns true if the page is from a PDF document.
</dl>

<h2>
StructuredText
</h2>

<p>
StructuredText objects hold text from a page that has been analyzed and grouped into blocks, lines and spans.
</p>

<dl>
<dt>StructuredText#walk(textWalker)
<dd>Call callback methods on the textWalker while replaying the structured text contents.
<dt>StructuredText#search(needle)
<dd>Search the text for all instances of 'needle', and return an array with rectangles of all matches found.
<dt>StructuredText#highlight(p, q)
<dd>Return an array with rectangles needed to highlight a selection defined by the start and end points.
<dt>StructuredText#copy(p, q)
<dd>Return the text from the selection defined by the start and end points.
</dl>

<p>
A StructuredTextWalker has callback methods that are called when StructuredText#walk() walks over blocks, lines, characters and images.
<dl>
<dt>StructuredTextWalker#onImageBlock(bbox, transform, image)
<dd>Called when walking over an image, describing its location and transform.
<dt>StructuredTextWalker#beginTextBlock(bbox)
<dd>Called when walking over the beginning of a text block, describing its location.
<dt>StructuredTextWalker#endTextBlock()
<dd>Called when walking over the end of a text block.
<dt>StructuredTextWalker#beginLine(bbox, writingMode)
<dd>Called when walking over each beginning of text lines in a text block, describing its location and writing direction.
<dt>StructuredTextWalker#endLine()
<dd>Called when walking over the end of a text line.
<dt>StructuredTextWalker#onChar(utf, position, font, size, quad, color)
<dd>Called when walking over each character in a text line, describing its location, font, size, dimension and color.
</dl>

<h2>
ColorSpace
</h2>

<dl>
<dt>DeviceGray
<dd>The default grayscale colorspace.
<dt>DeviceRGB
<dd>The default RGB colorspace.
<dt>DeviceBGR
<dd>The default RGB colorspace, but with components in reverse order.
<dt>DeviceCMYK
<dd>The default CMYK colorspace.
<dt>DeviceLab
<dd>The default Lab colorspace.
<dt>ColorSpace#getNumberOfComponents()
<dd>A grayscale colorspace has one component, RGB has 3, CMYK has 4, and DeviceN may have any number of components.
<dt>ColorSpace#toString()
<dd>Return name of Colorspace.
<dt>ColorSpace#isGray()
<dd>Returns true if the object is a gray color space.
<dt>ColorSpace#isRGB()
<dd>Returns true if the object is an RGB color space.
<dt>ColorSpace#isCMYK()
<dd>Returns true if the object is a CMYK color space.
<dt>ColorSpace#isIndexed()
<dd>Returns true if the object is a Indexed color space.
<dt>ColorSpace#isLab()
<dd>Returns true if the object is a Lab color space.
<dt>ColorSpace#isDeviceN()
<dd>Returns true if the object is a Device N color space.
<dt>ColorSpace#isLabICC()
<dd>Returns true if the object is a Lab ICC color space.
<dt>ColorSpace#isSubtractive()
<dd>Returns true if the object is a subtractive color space.
<dt>ColorSpace#isDevice()
<dd>Returns true if the object is a Device color space.
<dt>ColorSpace#isDeviceGray()
<dd>Returns true if the object is a Deice gray color space.
<dt>ColorSpace#isDeviceCMYK()
<dd>Returns true if the object is a Deice CMYK color space.
</dl>

<h2>
Pixmap
</h2>

<p>
A Pixmap object contains a color raster image (short for pixel map).
The components in a pixel in the pixmap are all byte values, with the transparency as the last component.
A pixmap also has a location (x, y) in addition to its size; so that they can easily be used to represent
tiles of a page.

<dl>
<dt>new Pixmap(colorspace, bounds, alpha)
<dd>Create a new pixmap. The pixel data is <b>not</b> initialized; and will contain garbage.
<dt>Pixmap#clear(value)
<dd>Clear the pixels to the specified value. Pass 255 for white, or undefined for transparent.
<dt>Pixmap#bound()
<dd>Return the pixmap bounds.
<dt>Pixmap#getX()
<dt>Pixmap#getY()
<dt>Pixmap#getWidth()
<dt>Pixmap#getHeight()
<dt>Pixmap#getNumberOfComponents()
<dd>Number of colors; plus one if an alpha channel is present.
<dt>Pixmap#getAlpha()
<dd>True if alpha channel is present.
<dt>Pixmap#getStride()
<dd>Number of bytes per row.
<dt>Pixmap#getColorSpace()
<dt>Pixmap#getXResolution()
<dt>Pixmap#getYResolution()
<dd>Pixmap resolution in dots per inch.
<dt>Pixmap#getSample(x, y, k)
<dd>Get the value of component k at position x, y (relative to the image origin: 0, 0 is the top left pixel).
<dt>Pixmap#setResolution(xRes, yRes)
<dd>Set X/Y resolution in dots per inch.
<dt>Pixmap#saveAsPNG(fileName)
<dd>Save the pixmap as a PNG. Only works for Gray and RGB images.
<dt>Pixmap#saveAsJPEG(fileName, quality)
<dd>Save the pixmap as a JPEG. Only works for Gray, RGB, and CMYK images.
<dt>Pixmap#saveAsPAM(fileName)
<dd>Save the pixmap as a PAM.
<dt>Pixmap#saveAsPNM(fileName)
<dd>Save the pixmap as a PNM. Only works for Gray and RGB images without alpha.
<dt>Pixmap#saveAsPBM(fileName)
<dt>Pixmap#saveAsPKM(fileName)
<dd>Save the pixmap as a PBM/PKM. Only works for Gray and CMYK images without alpha.
<dt>Pixmap#invert()
<dd>Invert all pixel. All components are processed, except alpha which is unchanged.
<dt>Pixmap#invertLuminance()
<dd>Transform all pixels so that luminance of each pixel is inverted, and the chrominance remains as unchanged as possible. All components are processed, except alpha which is unchanged.
<dt>Pixmap#gamma(gamma)
<dd>Apply gamma correction to pixmap. All components are processed, except alpha which is unchanged.
<dt>Pixmap#tint(black, white)
<dd>Tint all pixels in an RGB, BGR or Gray pixmap. Map black and white respectively to the given hex RGB values.
<dt>Pixmap#warp(points, width, height)
<dd>Return a warped subsection of the pixmap, where the result has the requested dimensions. Points give the
corner points of a convex quadrilateral within the pixmap to be warped, represented as [x0, y0, x1, y1, x2, y2, x3, y3].
<dt>Pixmap#convertToColorSpace(colorspace, proof, defaultColorSpaces, colorParams, keepAlpha)
<dd>Convert pixmap into a new pixmap of a desired colorspace. A proofing colorspace, a set of default colorspaces and color parameters used during conversion may be specified. Finally a boolean indicates if alpha should be preserved (default is to not preserve alpha).
</dl>

<h2>
DrawDevice
</h2>

<p>
The DrawDevice can be used to render to a Pixmap; either by running a Page with it or by calling its methods directly.

<dl>
<dt>new DrawDevice(transform, pixmap)
<dd>Create a device for drawing into a pixmap. The pixmap bounds used should match the transformed page bounds,
or you can adjust them to only draw a part of the page.
</dl>

<h2>
DisplayList and DisplayListDevice
</h2>

<p>
A display list records all the device calls for playback later.
If you want to run a page through several devices, or run it multiple times for any other reason,
recording the page to a display list and replaying the display list may be a performance gain
since then you can avoid reinterpreting the page each time. Be aware though, that a display list
will keep all the graphics required in memory, so will increase the amount of memory required.

<dl>
<dt>new DisplayList(mediabox)
<dd>Create an empty display list. The mediabox rect has the bounds of the page in points.
<dt>DisplayList#run(device, transform)
<dd>Play back the recorded device calls onto the device.
<dt>DisplayList#bound()
<dd>Returns a rectangle containing the dimensions of the display list contents.
<dt>DisplayList#toPixmap(transform, colorspace, alpha)
<dd>Render display list to a pixmap. If alpha is true, it will render to a transparent background, otherwise white.
<dt>DisplayList#toStructuredText(options)
<dd>Extract the text in the display list into a StructuredText object.
The options argument is a comma separated list of flags: preserve-ligatures, preserve-whitespace, preserve-spans, and preserve-images.
<dt>DisplayList#search(needle)
<dd>Search the display list text for all instances of 'needle', and return an array with rectangles of all matches found.
</dl>

<dl>
<dt>new DisplayListDevice(displayList)
<dd>Create a device for recording onto a display list.
</dl>

<h2>
Device
</h2>

<p>
All built-in devices have the methods listed below. Any function that accepts a device will also
accept a JavaScript object with the same methods. Any missing methods are simply ignored, so you
only need to create methods for the device calls you care about.

<p>
Many of the methods take graphics objects as arguments: Path, Text, Image and Shade.

<p>
The stroking state is a dictionary with keys for:
<dl>
<dt>StrokingState.startCap, .dashCap, .endCap:
<dd>"Butt", "Round", "Square", or "Triangle".
<dt>StrokingState.lineCap:
<dd>Set startCap, dashCap, and endCap all at once.
<dt>StrokingState.lineJoin:
<dd>"Miter", "Round", "Bevel", or "MiterXPS".
<dt>StrokingState.lineWidth:
<dd>Thickness of the line.
<dt>StrokingState.miterLimit:
<dd>Maximum ratio of the miter length to line width, before beveling the join instead.
<dt>StrokingState.dashPhase:
<dd>Starting offset for dash pattern.
<dt>StrokingState.dashes:
<dd>Array of on/off dash lengths.
</dl>

<p>
Colors are specified as arrays with the appropriate number of components for the color space.

<p>
The methods that clip graphics must be balanced with a corresponding popClip.

<dl>
<dt>Device#fillPath(path, evenOdd, transform, colorspace, color, alpha, colorParams)
<dt>Device#strokePath(path, stroke, transform, colorspace, color, alpha, colorParams)
<dt>Device#clipPath(path, evenOdd, transform)
<dt>Device#clipStrokePath(path, stroke, transform)
<dd>Fill/stroke/clip a path.
</dl>

<dl>
<dt>Device#fillText(text, transform, colorspace, color, alpha, colorParams)
<dt>Device#strokeText(text, stroke, transform, colorspace, color, alpha, colorParams)
<dt>Device#clipText(text, transform)
<dt>Device#clipStrokeText(text, stroke, transform)
<dd>Fill/stroke/clip a text object.
<dt>Device#ignoreText(text, transform)
<dd>Invisible text that can be searched but should not be visible, such as for overlaying a scanned OCR image.
</dl>

<dl>
<dt>Device#fillShade(shade, transform, alpha, colorParams)
<dd>Fill a shade (a.k.a. gradient). TODO: this details of gradient fills are not exposed to JavaScript yet.
<dt>Device#fillImage(shade, transform, alpha, colorParams)
<dd>Draw an image. An image always fills a unit rectangle [0,0,1,1], so must be transformed to be placed and drawn at the appropriate size.
<dt>Device#fillImageMask(image, transform, colorspace, color, alpha, colorParams)
<dd>An image mask is an image without color. Fill with the color where the image is opaque.
<dt>Device#clipImageMask(image, transform)
<dd>Clip graphics using the image to mask the areas to be drawn.
</dl>

<dl>
<dt>Device#beginMask(area, luminosity, backdropColorspace, backdropColor, backdropAlpha, colorParams)
<dt>Device#endMask()
<dd>Create a soft mask. Any drawing commands between beginMask and endMask are grouped and used as a clip mask.
If luminosity is true, the mask is derived from the luminosity (grayscale value) of the graphics drawn;
otherwise the color is ignored completely and the mask is derived from the alpha of the group.
</dl>

<dl>
<dt>Device#popClip()
<dd>Pop the clip mask installed by the last clipping operation.
</dl>

<dl>
<dt>Device#beginGroup(area, isolated, knockout, blendmode, alpha)
<dt>Device#endGroup()
<dd>Push/pop a transparency blending group. Blendmode is one of the standard PDF blend modes: "Normal", "Multiply", "Screen", etc. See the PDF reference for details on isolated and knockout.
</dl>

<dl>
<dt>Device#beginTile(areaRect, viewRect, xStep, yStep, transform, id)
<dt>Device#endTile()
<dd>Draw a tiling pattern. Any drawing commands between beginTile and endTile are grouped and then repeated across the whole page.
Apply a clip mask to restrict the pattern to the desired shape.
</dl>

<dl>
<dt>Device#beginLayer(tag)
<dt>Device#endLayer()
<dd>Begin/end a marked-content layer with the given tag.
</dl>

<dl>
<dt>Device#renderFlags(set, clear)
<dd>Set/clear device rendering flags. Both set and clear are arrays where each element is a flag name:
"mask", "color", "uncacheable", "fillcolor-undefined", "strokecolor-undefined", "startcap-undefined",
"dashcap-undefined", "endcap-undefined", "linejoin-undefined", "miterlimit-undefined",
"linewidth-undefined", "bbox-defined", or "gridfit-as-tiled".
<dt>Device#setDefaultColorSpaces(defaults)
<dd>Change the set of default colorspaces for the device. See the DefaultColorSpaces object.
</dl>

<dl>
<dt>Device#beginStructure(standard, raw, uid)
<dt>Device#endStructure()
<dd>Begin/end a standard structure element, the raw tag name and a unique identifier.
</dl>

<dl>
<dt>Device#beginMetatext(type, text)
<dt>Device#endMetatext()
<dd>Begin/end meta text information, the type (either of "ActualText", "Alt", "Abbreviation", or "Title") and the text value itself.
</dl>

<dl>
<dt>Device#close()
<dd>Tell the device that we are done, and flush any pending output.
</dl>

<p>
ColorParams is a dictionary with keys for:
<dl>
<dt>ColorParams.renderingIntent:
<dd>Either of "Perceptual", "RelativeColorimetric", "Saturation" or "AbsoluteColorimetric".
<dt>ColorParams.blackPointCompensation:
<dd>True if black point compensation is activated.
<dt>ColorParams.overPrinting:
<dd>True if overprint is activated.
<dt>ColorParams.overPrintMode:
<dd>The overprint mode.
</dl>

<p>
DefaultColorSpaces is a an object with keys for:
<dl>
<dt>DefaultColorSpaces#getDefaultGray()
<dt>DefaultColorSpaces#getDefaultRGB()
<dt>DefaultColorSpaces#getDefaultCMYK()
<dt>DefaultColorSpaces#getOutputIntent()
<dd>Get the default gray/RGB/CMYK colorspace, or the output intent.
<dt>DefaultColorSpaces#setDefaultGray(colorspace)
<dt>DefaultColorSpaces#setDefaultRGB(colorspace)
<dt>DefaultColorSpaces#setDefaultCMYK(colorspace)
<dt>DefaultColorSpaces#setOutputIntent(colorspace)
<dd>Set the default gray/RGB/CMYK colorspace, or the output intent, to the provided colorspace.
</dl>

<h2>
Path
</h2>

<p>
A Path object represents vector graphics as drawn by a pen. A path can be either stroked or filled, or used as a clip mask.

<dl>
<dt>new Path()
<dd>Create a new empty path.
<dt>Path#bound(stroke, transform)
<dd>Return a bounding rectangle for the path.
<dt>Path#moveTo(x, y)
<dd>Lift and move the pen to the coordinate.
<dt>Path#lineTo(x, y)
<dd>Draw a line to the coordinate.
<dt>Path#curveTo(x1, y1, x2, y2, x3, y3)
<dd>Draw a cubic bezier curve to (x3,y3) using (x1,y1) and (x2,y2) as control points.
<dt>Path#curveToV(cx, cy, ex, ey)
<dd>Draw a cubic bezier curve to (ex,ey) using the start point and (cx,cy) as control points.
<dt>Path#curveToY(cx, cy, ex, ey)
<dd>Draw a cubic bezier curve to (ex,ey) using the (cx,cy) and (ex, ey) as control points.
<dt>Path#closePath()
<dd>Close the path by drawing a line to the last moveTo.
<dt>Path#rect(x1, y1, x2, y2)
<dd>Shorthand for moveTo, lineTo, lineTo, lineTo, closePath to draw a rectangle.
<dt>Path#walk(pathWalker)
<dd>Call moveTo, lineTo, curveTo and closePath methods on the pathWalker object to replay the path.
<dt>Path#transform(transform)
<dd>Transform path by the given transform matrix.
</dl>

<p>
A PathWalker has callback methods that are called when Path#walk() walks over move to, line to, curve to and close path operators in a Path.
<dl>
<dt>PathWalker#moveTo(x, y)
<dd>Called when walking over a moveTo, moving the current point to x, y.
<dt>PathWalker#lineTo(x, y)
<dd>Called when walking over a lineTo, requesting a line to be drawn from the current point to x, y.
<dt>PathWalker#curveTo(x1, y1, x2, y2, x3, y3)
<dd>Called when walking over a curveTo, requesting a Bézier curve from current point to x3, y3 with x1, y1 and x2, y2 as control points.
<dt>PathWalker#closePath()
<dd>Called when walking over a closePath, closing the current path.
</dl>

<h2>
Text
</h2>

<p>
A Text object contains text.

<dl>
<dt>new Text()
<dd>Create a new empty text object.
<dt>Text#showGlyph(font, transform, glyph, unicode, wmode)
<dd>Add a glyph to the text object. Transform is the text matrix, specifying font size and glyph location. For example: <code>[size,0,0,-size,x,y]</code>.
Glyph and unicode may be -1 for n-to-m cluster mappings.
For example, the "fi" ligature would be added in two steps: first the glyph for the 'fi' ligature and the unicode value for 'f';
then glyph -1 and the unicode value for 'i'.
WMode is 0 for horizontal writing, and 1 for vertical writing.
<dt>Text#showString(font, transform, string)
<dd>Add a simple string to the text object. Will do font substitution if the font does not have all the unicode characters required.
<dt>Text#walk(textWalker)
<dd>Call the showGlyph method on the textWalker object for each glyph in the text object.
</dl>

<h2>
Font
</h2>

<p>
Font objects can be created from TrueType, OpenType, Type1 or CFF fonts.
In PDF there are also special Type3 fonts.

<dl>
<dt>new Font(fontName or fileName)
<dd>Create a new font, either using a built-in font name or a filename.
<br>The built-in standard PDF fonts are:
Times-Roman, Times-Italic, Times-Bold, Times-BoldItalic,
Helvetica, Helvetica-Oblique, Helvetica-Bold, Helvetica-BoldOblique,
Courier, Courier-Oblique, Courier-Bold, Courier-BoldOblique,
Symbol, and ZapfDingbats.
<br>The built-in CJK fonts are referenced by language code: zh-Hant, zh-Hans, ja, ko.
<dt>Font#getName()
<dd>Get the font name.
<dt>Font#encodeCharacter(unicode)
<dd>Get the glyph index for a unicode character. Glyph zero (.notdef) is returned if the font does not have a glyph for the character.
<dt>Font#advanceGlyph(glyph, wmode)
<dd>Return advance width for a glyph in either horizontal or vertical writing mode.
<dt>Font#isBold()
<dt>Font#isItalic()
<dt>Font#isMono()
<dt>Font#isSerif()
<dd>Returns true if font is bold/italic/monospaced/serif.
</dl>

<h2>
Image
</h2>

<p>
Image objects are similar to Pixmaps, but can contain compressed data.

<dl>
<dt>new Image(pixmap or fileName)
<dd>Create a new image from a pixmap data, or load an image from a file.
<dt>Image#getWidth()
<dt>Image#getHeight()
<dd>Image size in pixels.
<dt>Image#getXResolution()
<dt>Image#getYResolution()
<dd>Image resolution in dots per inch.
<dt>Image#getColorSpace()
<dt>Image#getNumberOfComponents()
<dt>Image#getBitsPerComponent()
<dt>Image#getInterpolate()
<dd>Returns true if interpolation was used during decoding.
<dt>Image#getColorKey()
<dd>Returns an array with 2 * N integers for an N component image with color key masking, or null if masking is not used. Each pair of integers define an interval, and component values within that interval are not painted.
<dt>Image#getDecode()
<dd>Returns an array with 2 * N numbers for an N component image with color mapping, or null if if mapping is not used. Each pair of numbers define the lower and upper values to which the component values are mapped linearly.
<dt>Image#getOrientation()
<dd>Returns the orientation of the image:
<dl>
<dt>1
<dd>no rotation or flipping
<dt>2
<dd>rotate counter clockwise by 90 degrees
<dt>4
<dd>rotate counter clockwise by 180 degrees
<dt>5
<dd>rotate counter clockwise by 270 degrees
<dt>6
<dd>flip on X, then rotate counter clockwise by 90 degrees
<dt>7
<dd>flip on X, then rotate counter clockwise by 180 degrees
<dt>8
<dd>flip on X, then rotate counter clockwise by 270 degrees
</dl>
<dt>Image#setOrientation(orientation)
<dd>Set the image orientation to the given orientation.
<dt>Image#getImageMask()
<dd>Returns true if this image is an image mask.
<dt>Image#getMask()
<dd>Get another Image used as a mask for this one.
<dt>Image#toPixmap(scaledWidth, scaledHeight)
<dd>Create a pixmap from the image. The scaledWidth and scaledHeight arguments are optional,
but may be used to decode a down-scaled pixmap.
</dl>

<h2>
Document Writer
</h2>

<p>
Document writer objects are used to create new documents in several formats.

<dl>
<dt>new DocumentWriter(filename, format, options)
<dd>Create a new document writer to create a document with the specified format and output options.
If format is null it is inferred from the filename extension. The options argument is a comma separated list
of flags and key-value pairs. See below for more details.
<dt>DocumentWriter#beginPage(mediabox)
<dd>Begin rendering a new page. Returns a Device that can be used to render the page graphics.
<dt>DocumentWriter#endPage(device)
<dd>Finish the page rendering.
The argument must be the same device object that was returned by the beginPage method.
<dt>DocumentWriter#close()
<dd>Finish the document and flush any pending output.
</dl>

<p>
The output formats and options supported are the same as in the
<a href="manual-mutool-convert.html">mutool convert</a> command.

<h2>
PDFDocument and PDFObject
</h2>

<p>
With MuPDF it is also possible to create, edit and manipulate PDF documents
using low level access to the objects and streams contained in a PDF file.
A PDFDocument object is also a Document object. You can test a Document object
to see if it is safe to use as a PDFDocument by calling document.isPDF().

<dl>
<dt>new PDFDocument()
<dd>Create a new empty PDF document.
<dt>new PDFDocument(fileName)
<dd>Load a PDF document from file.
<dt>PDFDocument#save(fileName, options)
<dd>Write the PDF document to file.
The write options are a string of comma separated options (see the document writer <a href="#pdf-write-options">options</a>).
<dt>PDFDocument#canBeSavedIncrementally()
<dd>Returns true if the document can be saved incrementally, e.g. repaired documents or applying redactions prevents incremental saves.
<dt>PDFDocument#countVersions()
<dd>Returns the number of versions of the document in a PDF file, typically 1 + the number of updates.
<dt>PDFDocument#countUnsavedVersions()
<dd>Returns the number of unsaved updates to the document.
<dt>PDFDocument#validateChangeHistory()
<dd>Check the history of the document, return the last version that checks out OK. Returns 0 if the entire history is ok, 1 if the next to last version is ok, but the last version has issues, etc.
<dt>PDFDocument#hasUnsavedChanges()
<dd>Returns true if the document has been saved since it was last opened or saved.
<dt>PDFDocument#wasPureXFA()
<dd>Returns true if the document was an XFA form without AcroForm fields.
<dt>PDFDocument#wasRepaired()
<dd>Returns true if the document was repaired when opened.
<dt>PDFDocument#setPageLabels(index, style, prefix, start)
<dd>Sets the page label numbering for the page and all pages following it, until the next page with an attached label.
Style can be one of the following strings: "", "D", "R", "r", "A", or "a".
Start is the ordinal with which to start numbering.
<dt>PDFDocument#deletePageLabels(index)
<dd>Removes any associated page label from the page.
<dt>PDFDocument#getVersion()
<dd>Returns the PDF document version as an intenger multiplied by 10, so e.g. a PDF-1.4 document would return 14.
</dl>

<h3>
PDF Object Access
</h3>

<p>
A PDF document contains objects, similar to those in JavaScript: arrays, dictionaries, strings, booleans, and numbers.
At the root of the PDF document is the trailer object; which contains pointers to the meta data dictionary and the
catalog object which contains the pages and other information.

<p>
Pointers in PDF are also called indirect references,
and are of the form "32 0 R" (where 32 is the object number, 0 is the generation, and R is magic syntax).
All functions in MuPDF dereference indirect references automatically.

<p>
PDF has two types of strings: /Names and (Strings). All dictionary keys are names.

<p>
Some dictionaries in PDF also have attached binary data. These are called streams, and may be compressed.

<dl>
<dt>PDFDocument#getTrailer()
<dd>The trailer dictionary. This contains indirect references to the Root and Info dictionaries.
<dt>PDFDocument#countObjects()
<dd>Return the number of objects in the PDF. Object number 0 is reserved, and may not be used for anything.
<dt>PDFDocument#createObject()
<dd>Allocate a new numbered object in the PDF, and return an indirect reference to it.
The object itself is uninitialized.
<dt>PDFDocument#deleteObject(obj)
<dd>Delete the object referred to by the indirect reference.
</dl>

<p>
PDFObjects are always bound to the document that created them.
Do NOT mix and match objects from one document with another document!

<dl>
<dt>PDFDocument#addObject(obj)
<dd>Add 'obj' to the PDF as a numbered object, and return an indirect reference to it.
<dt>PDFDocument#addStream(buffer, object)
<dd>Create a stream object with the contents of 'buffer', add it to the PDF, and return an indirect reference to it. If object is defined, it will be used as the stream object dictionary.
<dt>PDFDocument#addRawStream(buffer, object)
<dd>Create a stream object with the contents of 'buffer', add it to the PDF, and return an indirect reference to it.
If object is defined, it will be used as the stream object dictionary.
The buffer must contain already compressed data that matches the Filter and DecodeParms.
<dt>PDFDocument#newNull()
<dt>PDFDocument#newBoolean(boolean)
<dt>PDFDocument#newInteger(number)
<dt>PDFDocument#newReal(number)
<dt>PDFDocument#newString(string)
<dt>PDFDocument#newByteString(byteString)
<dt>PDFDocument#newName(string)
<dt>PDFDocument#newIndirect(objectNumber, generation)
<dt>PDFDocument#newArray()
<dt>PDFDocument#newDictionary()
</dl>

<p>
The following functions can be used to copy objects from one document to another:

<dl>
<dt>PDFDocument#graftObject(object)
<dd>Deep copy an object into the destination document. This function will not remember previously
copied objects.
If you are copying several objects from the same source document using multiple calls, you should
use a graft map instead.
<dt>PDFDocument#newGraftMap()
<dd>Create a graft map on the destination document, so that objects that have already been copied can be found again.
Each graft map should only be used with <i>one</i> source document! Make sure to create a new graft map for each source document used.
<dt>PDFGraftMap#graftObject(object)
<dd>Use the graft map to copy objects, with the ability to remember previously copied objects.
<dt>PDFGraftMap#graftPage(map, dstPageNumber, srcDoc, srcPageNumber)
<dd>Graft a page at the given page number from the source document to the requested page number in the destination document connected to the map.
<dt>PDFDocument#graftPage(dstDoc, dstPageNumber, srcDoc, srcPageNumber)
<dd>Graft a page and its resources at the given page number from the source document to the requested page number in the destination document.
</dl>

<p>
All functions that take PDF objects, do automatic translation between JavaScript objects
and PDF objects using a few basic rules. Null, booleans, and numbers are translated directly.
JavaScript strings are translated to PDF names, unless they are surrounded by parentheses:
"Foo" becomes the PDF name /Foo and "(Foo)" becomes the PDF string (Foo).

<p>
Arrays and dictionaries are recursively translated to PDF arrays and dictionaries.
Be aware of cycles though! The translation does NOT cope with cyclic references!

<p>
The translation goes both ways: PDF dictionaries and arrays can be accessed similarly
to JavaScript objects and arrays by getting and setting their properties.

<dl>
<dt>PDFObject#get(key or index)
<dt>PDFObject#put(key or index, value)
<dt>PDFObject#delete(key or index)
<dd>Access dictionaries and arrays. Dictionaries and arrays can also be accessed using normal property syntax: obj.Foo = 42; delete obj.Foo; x = obj[5].
<dt>PDFObject#resolve()
<dd>If the object is an indirect reference, return the object it points to; otherwise return the object itself.
<dt>PDFObject#compare(other)
<dd>Compare the object to another one. Returns 0 on match, non-zero on mismatch. Streams always mismatch.
<dt>PDFObject#isArray()
<dt>PDFObject#isDictionary()
<dt>PDFObject#forEach(function(key,value){...})
<dd>Iterate over all the entries in a dictionary or array and call fun for each key-value pair.
<dt>PDFObject#length
<dd>Length of the array.
<dt>PDFObject#push(item)
<dd>Append item to the end of the array.
<dt>PDFObject#toString()
<dd>Returns the object as a pretty-printed string.
<dt>PDFObject#valueOf()
<dd>Convert primitive PDF objects to a corresponding primitive null, boolean, number or string javascript objects. Indirect PDF objects get converted to the string "R" while PDF names are converted to plain strings. PDF arrays or dictionaries are returned unchanged.
</dl>

<p>
The only way to access a stream is via an indirect object, since all streams
are numbered objects.

<dl>
<dt>PDFObject#isIndirect()
<dd>Is the object an indirect reference.
<dt>PDFObject#asIndirect()
<dd>Return the object number the indirect reference points to.
<dt>PDFObject#isStream()
<dd>True if the object is an indirect reference pointing to a stream.
<dt>PDFObject#readStream()
<dd>Read the contents of the stream object into a Buffer.
<dt>PDFObject#readRawStream()
<dd>Read the raw, uncompressed, contents of the stream object into a Buffer.
<dt>PDFObject#writeObject(obj)
<dd>Update the object the indirect reference points to.
<dt>PDFObject#writeStream(buffer)
<dd>Update the contents of the stream the indirect reference points to.
This will update the Length, Filter and DecodeParms automatically.
<dt>PDFObject#writeRawStream(buffer)
<dd>Update the contents of the stream the indirect reference points to.
The buffer must contain already compressed data that matches the Filter and DecodeParms.
This will update the Length automatically, but leave the Filter and DecodeParms untouched.
</dl>

<p>
Primitive PDF objects such as booleans, names, and numbers can usually be treated like JavaScript values.
When that is not sufficient use these functions:

<dl>
<dt>PDFObject#isNull()
<dd>Is the object the 'null' object?
<dt>PDFObject#isBoolean()
<dd>Is the object a boolean?
<dt>PDFObject#asBoolean()
<dd>Get the boolean primitive value.
<dt>PDFObject#isNumber()
<dd>Is the object a number?
<dt>PDFObject#asNumber()
<dd>Get the number primitive value.
<dt>PDFObject#isName()
<dd>Is the object a name?
<dt>PDFObject#asName()
<dd>Get the name as a string.
<dt>PDFObject#isString()
<dd>Is the object a string?
<dt>PDFObject#asString()
<dd>Convert a "text string" to a javascript unicode string.
<dt>PDFObject#asByteString()
<dd>Convert a string to an array of byte values.
</dl>

<h2>
PDF JavaScript actions
</h2>

<dl>
<dt>PDFDocument#enableJS()
<dd>Enable interpretation of document JavaScript actions.
<dt>PDFDocument#disableJS()
<dd>Disable interpretation of document JavaScript actions.
<dt>PDFDocument#isJSSupported()
<dd>Returns true if interpretation of document JavaScript actions is supported.
<dt>PDFDocument#setJSEventListener(listener)
<dd>Calls method onAlert whenever a document JS action trigger an alert.
</dl>

<h2>
PDF journalling
</h2>

<dl>
<dt>PDFDocument#enableJournal()
<dd>Activate journalling for the document.
<dt>PDFDocument#getJournal()
<dd>Returns a PDF journal object, described below.
<dt>PDFDocument#beginOperation()
<dd>Begin a journal operation
<dt>PDFDocument#beginImplicitOperation()
<dd>Begin an implicit journal operation. Implicit operations are operations that happen due to other operations, e.g. updating an annotation.
<dt>PDFDocument#endOperation()
<dd>End a previously started normal or implicit operation. After this it can be undone/redone using the methods below.
<dt>PDFDocument#canUndo()
<dd>Returns true if undo is possible in this state.
<dt>PDFDocument#canRedo()
<dd>Returns true if redo is possible in this state.
<dt>PDFDocument#undo()
<dd>Move backwards in the undo history. Changes to the document after this throws away all subsequent history.
<dt>PDFDocument#redo()
<dd>Move forwards in the undo history.
</dl>

<p>
A PDF journal object contains a numbered array of operations and a reference into this list indicating the current position.
<dl>
<dt>PDFJournal.position:
<dd>The current position in the journal.
<dt>PDFJournal.steps:
<dd>An array containing the name of each step in the journal.
</dl>

<h3>
PDF Page Access
</h3>

<p>
All page objects are structured into a page tree, which defines the order the pages appear in.

<dl>
<dt>PDFDocument#countPages()
<dd>Number of pages in the document.
<dt>PDFDocument#findPage(number)
<dd>Return the page object for a page number. The first page is number zero.
<dt>PDFDocument#findPageNumber(pageObject)
<dd>Given a pageObject, lookup the page number in the document.
<dt>PDFDocument#deletePage(number)
<dd>Delete the numbered page.
<dt>PDFDocument#insertPage(at, page)
<dd>Insert the page object in the page tree at the location. If 'at' is -1, at the end of the document.
</dl>

<p>
Pages consist of a content stream, and a resource dictionary containing all of the fonts and images used.

<dl>
<dt>PDFDocument#addPage(mediabox, rotate, resources, contents)
<dd>Create a new page object. Note: this function does NOT add it to the page tree.
<dt>PDFDocument#addSimpleFont(font, encoding)
<dd>Create a PDF object from the Font object as a simple font.
Encoding is either "Latin" (CP-1252), "Greek" (ISO-8859-7), or "Cyrillic" (KOI-8U).
The default is "Latin".
<dt>PDFDocument#addCJKFont(font, language, wmode, style)
<dd>Create a PDF object from the Font object as a UTF-16 encoded CID font for the given
language ("zh-Hant", "zh-Hans", "ko", or "ja"),
writing mode ("H" or "V"),
and style ("serif" or "sans-serif").
<dt>PDFDocument#addFont(font)
<dd>Create a PDF object from the Font object as an Identity-H encoded CID font.
<dt>PDFDocument#addImage(image)
<dd>Create a PDF object from the Image object.
<dt>PDFDocument#loadImage(obj)
<dd>Load an Image from a PDF object (typically an indirect reference to an image resource).
</dl>

<dl>
<dt>PDFPage#process(processor)
<dd>Run through the page contents stream and call methods on the supplied PDF processor.
<dt>PDFPage#toPixmap(transform, colorspace, alpha, renderExtra, usage)
<dd>Render the page into a Pixmap using the given colorspace and alpha while applying the transform. Rendering of annotations/widgets can be disabled. A page can be rendered for e.g. "View" or "Print" usage.
<dt>PDFPage#getTransform()
<dd>Return the transform from Fitz page space (upper left page origin, y descending, 72 dpi) to PDF user space (arbitrary page origin, y ascending, UserUnit dpi). This may
</dl>

<h3>
PDF Processor
</h3>

<p>
A PDF processor provides callbacks that get called for each PDF operator handled by PDFPage#process().
The callbacks whose names start with op_ correspond to each PDF operator.
Refer to the PDF specification for what these do and what the callback arguments are.

<dl>
<dt>PDFProcessor#push_resources(resources)
<dt>PDFProcessor#pop_resources()
</dl>

<p>
General graphics state callbacks:
<dl>
<dt>PDFProcessor#op_w(lineWidth)
<dt>PDFProcessor#op_j(lineJoin)
<dt>PDFProcessor#op_J(lineCap)
<dt>PDFProcessor#op_M(miterLimit)
<dt>PDFProcessor#op_d(dashPattern, phase)
<dt>PDFProcessor#op_ri(intent)
<dt>PDFProcessor#op_i(flatness)
<dt>PDFProcessor#op_gs(name, extGState)
</dl>

<p>
Special graphics state:
<dl>
<dt>PDFProcessor#op_q()
<dt>PDFProcessor#op_Q()
<dt>PDFProcessor#op_cm(a, b, c, d, e, f)
</dl>

<p>
Path construction:
<dl>
<dt>PDFProcessor#op_m(x, y)
<dt>PDFProcessor#op_l(x, y)
<dt>PDFProcessor#op_c(x1, y1, x2, y2, x3, y3)
<dt>PDFProcessor#op_v(x2, y2, x3, y3)
<dt>PDFProcessor#op_y(x1, y1, x3, y3)
<dt>PDFProcessor#op_h()
<dt>PDFProcessor#op_re(x, y, w, h)
</dl>

<p>
Path painting:
<dl>
<dt>PDFProcessor#op_S()
<dt>PDFProcessor#op_s()
<dt>PDFProcessor#op_F()
<dt>PDFProcessor#op_f()
<dt>PDFProcessor#op_fstar()
<dt>PDFProcessor#op_B()
<dt>PDFProcessor#op_Bstar()
<dt>PDFProcessor#op_b()
<dt>PDFProcessor#op_bstar()
<dt>PDFProcessor#op_n()
</dl>

<p>
Clipping paths:
<dl>
<dt>PDFProcessor#op_W()
<dt>PDFProcessor#op_Wstar()
</dl>

<p>
Text objects:
<dl>
<dt>PDFProcessor#op_BT()
<dt>PDFProcessor#op_ET()
</dl>

<p>
Text state:
<dl>
<dt>PDFProcessor#op_Tc(charSpace)
<dt>PDFProcessor#op_Tw(wordSpace)
<dt>PDFProcessor#op_Tz(scale)
<dt>PDFProcessor#op_TL(leading)
<dt>PDFProcessor#op_Tf(name, size)
<dt>PDFProcessor#op_Tr(render)
<dt>PDFProcessor#op_Ts(rise)
</dl>

<p>
Text positioning:
<dl>
<dt>PDFProcessor#op_Td(tx, ty)
<dt>PDFProcessor#op_TD(tx, ty)
<dt>PDFProcessor#op_Tm(a, b, c, d, e, f)
<dt>PDFProcessor#op_Tstar()
</dl>

<p>
Text showing:
<dl>
<dt>PDFProcessor#op_TJ(textArray) number/string
<dt>PDFProcessor#op_Tj(stringOrByteArray)
<dt>PDFProcessor#op_squote(stringOrByteArray)
<dt>PDFProcessor#op_dquote(wordSpace, charSpace, stringOrByteArray)
</dl>

<p>
Type 3 fonts:
<dl>
<dt>PDFProcessor#op_d0(wx, wy)
<dt>PDFProcessor#op_d1(wx, wy, llx, lly, urx, ury)
</dl>

<p>
Color:
<dl>
<dt>PDFProcessor#op_CS(name, colorspace)
<dt>PDFProcessor#op_cs(name, colorspace)
<dt>PDFProcessor#op_SC_color(color)
<dt>PDFProcessor#op_sc_color(color)
<dt>PDFProcessor#op_SC_pattern(name, patternID, color)
<dd>API not settled, arguments may change in the future.
<dt>PDFProcessor#op_sc_pattern(name, patternID, color)
<dd>API not settled, arguments may change in the future.
<dt>PDFProcessor#op_SC_shade(name, shade)
<dd>API not settled, arguments may change in the future.
<dt>PDFProcessor#op_sc_shade(name, shade)
<dd>API not settled, arguments may change in the future.
<dt>PDFProcessor#op_G(gray)
<dt>PDFProcessor#op_g(gray)
<dt>PDFProcessor#op_RG(r, g, b)
<dt>PDFProcessor#op_rg(r, g, b)
<dt>PDFProcessor#op_K(c, m, y, k)
<dt>PDFProcessor#op_k(c, m, y, k)
</dl>

<p>
Shadings, images and XObjects:
<dl>
<dt>PDFProcessor#op_BI(image, colorspace)
<dt>PDFProcessor#op_sh(name, shade)
<dd>API not settled, arguments may change in the future.
<dt>PDFProcessor#op_Do_image(name, image)
<dt>PDFProcessor#op_Do_form(xobject, resources)
</dl>

<p>
Marked content:
<dl>
<dt>PDFProcessor#op_MP(tag)
<dt>PDFProcessor#op_DP(tag, raw)
<dt>PDFProcessor#op_BMC(tag)
<dt>PDFProcessor#op_BDC(tag, raw)
<dt>PDFProcessor#op_EMC()
</dl>

<p>
Compatibility:
<dl>
<dt>PDFProcessor#op_BX()
<dt>PDFProcessor#op_EX()
</dl>

<h3>
Embedded files in PDFs
</h3>

<p>
After embedding a file into a PDF, it can be connected to an annotation using PDFAnnotation#setFilespec()

<dl>
<dt>PDFDocument#addEmbeddedFile(filename, mimetype, contents, creationDate, modificationDate, addChecksum)
<dd>Embedded a file into the document, along with its name, mimetype, creation and modification dates. If a checksum is the file contents can be verified later. An indirect reference to the filespec PDF object is returned.
<dt>PDFDocument#getEmbeddedFileParams(filespecObject)
<dd>Return an EmbeddedFileParams describing the file referenced by the filespec object.
<dt>PDFDocument#getEmbeddedFileContents(filespecObject)
<dd>Returns a Buffer with the contents of the embedded file referenced by the filespec object.
<dt>PDFDocument#verifyEmbeddedFileChecksum(filespecObject)
<dd>Verify the MD5 checksum of the embedded file contents.
</dl>

<p>
An EmbeddedFileParams object contain metadata about an embedded file.
<dl>
<dt>EmbeddedFileParams.filename:
<dd>The name of the embedded file.
<dt>EmbeddedFileParams.mimetype:
<dd>The MIME type of the embedded file, or undefined if none exists.
<dt>EmbeddedFileParams.size:
<dd>The size in bytes of the embedded file contents.
<dt>EmbeddedFileParams.creationDate:
<dd>The creation date of the embedded file.
<dt>EmbeddedFileParams.modificationDate:
<dd>The modification date of the embedded file.
</dl>

<h3>
OutlineIterator
</h3>

<p>
An outline iterator is can be used to walk over all the items in an Outline and query their properties.
To be able to insert items at the end of a list of sibling items, it can also walk one item past the end of the list.

<dl>
<dt>OutlineIterator#item()
<dd>Return an OutlineIteratorItem or undefined if out of range.
<dt>OutlineIterator#next()
<dt>OutlineIterator#prev()
<dt>OutlineIterator#up()
<dt>OutlineIterator#down()
<dd>Move the iterator position next/prev/up/down. Returns 0 if the new position has a valid item, or 1 if the position contains no valid item, but one may be inserted at this position.
<dt>OutlineIterator#insert(item)
<dd>Insert item before the current item. The position does not change. Returns 0 if the position has a valid item, or 1 if the position has no valid item.
<dt>OutlineIterator#delete()
<dd>Delete the current item. This implicitly moves to the next item. Returns 0 if the new position has a valid item, or 1 if the position contains no valid item, but one may be inserted at this position.
<dt>OutlineIterator#update(item)
<dd>Updates the current item with the properties of the supplied item.
</dl>

<p>
An OutlineIteratorItem is a dictionary with keys for:
<dl>
<dt>OutlineIteratorItem.title:
<dd>The title of the item.
<dt>OutlineIteratorItem.uri:
<dd>A uri pointing to the destination. Likely to be a document internal link that can be resolved by Document#resolveLink(), otherwise a link to a web page.
<dt>OutlineIteratorItem.open:
<dd>Returns true if the item should be opened when shown in a tree view.
</dl>

<h3>
PDF Annotations
</h3>

<p>
PDFAnnotations belong to a specific PDFPage and may be created/changed/removed.
Because annotation appearances may change (for several reasons) it is possible
to scan through the annotations on a page and query them whether a re-render is
necessary. Finally redaction annotations can be applied to a PDFPage, destructively
removing content from the page.

<dl>
<dt>PDFPage#getAnnotations()
<dd>Return array of all annotations on the page.
<dt>PDFPage#createAnnotation(type)
<dd>Create a new blank annotation of a given annotation type: "Text", "Link",
"FreeText", "Line", "Square", "Circle", "Polygon", "PolyLine", "Highlight",
"Underline", "Squiggly", "StrikeOut", "Redact", "Stamp", "Caret", "Ink", "Popup",
"FileAttachment", "Sound", "Movie", "RichMedia", "Widget", "Screen",
"PrinterMark", "TrapNet", "Watermark", "3D" or "Projection".
<dt>PDFPage#deleteAnnotation(annot)
<dd>Delete the annotation from the page.
<dt>PDFPage#update()
<dd>Loop through all annotations of the page and update them. Returns true if
re-rendering is needed because at least one annotation was changed (due to
either events or javascript actions or annotation editing).
<dt>PDFPage#applyRedactions(blackboxes, imagemethod)
<dd>Apply redaction annotations to the page. Should black boxes be drawn at each redaction or not? Should affected images be ignored, entirely redacted or should just the covered part of the image be redacted?
</dl>

<p>
These are general methods to interact with annotations:

<dl>
<dt>PDFAnnotation#bound()
<dd>Returns a rectangle containing the location and dimension of the annotation.
<dt>PDFAnnotation#run(device, transform)
<dd>Calls the device functions to draw the annotation
<dt>PDFAnnotation#toPixmap(transform, colorspace, alpha)
<dd>Render the annotation into a Pixmap, using the transform and colorspace.
<dt>PDFAnnotation#toDisplayList()
<dd>Record the contents of the annotation into a DisplayList.
<dt>PDFAnnotation#getObject()
<dd>Get the underlying PDF object for an annotation.
<dt>PDFAnnotation#process(processor)
<dd>Run through the annotation appearance stream and call methods on the supplied PDF processor.
<dt>PDFAnnotation#setAppearance(appearance, state, transform, displaylist)
<dt>PDFAnnotation#setAppearance(appearance, state, transform, bbox, resources, contents)
<dd>Set the annotation appearance stream for the given appearance ("N", "R" or "D") and state (may be e.g. "On", "Off").
The desired appearance is given as a transform along with either a display list or a bounding box, a PDF dictionary of resources and a content stream.
<dt>PDFAnnotation#update()
<dd>Update the appearance stream to account for changes in the annotation.
<dt>PDFAnnotation#getHot(), #setHot(hot)
<dd>Get/set the annotation as being hot, i.e. that the pointer is hovering over the annotation.
<dt>PDFAnnotation#getHiddenForEditing(), #setHiddenForEditing(hidden)
<dd>Get/set a special annotation hidden flag for editing. This flag prevents the annotation from being rendered.
</dl>

<p>
These properties are available for all annotation types.

<dl>
<dt>PDFAnnotation#getType()
<dd>Return the annotation type.
<dt>PDFAnnotation#getFlags(), #setFlags(flags)
<dd>Get/set the annotation flags.
<dt>PDFAnnotation#getContents(), #setContents(text)
<dd>Get/set the annotation contents.
<dt>PDFAnnotation#getBorder(), #setBorder(width)
<dd>Get/set the annotation border line width in points. Use PDFAnnotation#setBorderWidth() to avoid removing the border effect.
<dt>PDFAnnotation#getColor(), #setColor(color)
<dd>Get/set the annotation color, represented as an array of up to 4 component values.
<dt>PDFAnnotation#getOpacity(), #setOpacity(opacity)
<dd>Get/set the annotation opacity.
<dt>PDFAnnotation#getCreationDate(), #setCreationDate(milliseconds)
<dd>Get the annotation creation date as a Date object. Set it to the number of milliseconds since the epoch.
<dt>PDFAnnotation#getModificationDate(), #setModificationDate(milliseconds)
<dd>Get the annotation modification date as a Date object. Set it to the number of milliseconds since the epoch.
<dt>PDFAnnotation#getQuadding(), #setQuadding(value)
<dd>Get/set the annotation quadding (justification), 0 for left-justified, 1 for centered, 2 for right-justified.
<dt>PDFAnnotation#getLanguage(), #setLanguage(language)
<dd>Get/Set the annotation language (or get inherit the document language).
</dl>

<p>
These properties are only present for some annotation types, so support for them must be checked before use.

<dl>
<dt>PDFAnnotation#getRect(), #setRect(rect)
<dd>Get/set the annotation bounding box.
<dt>PDFAnnotation#getDefaultAppearance(), #setDefaultAppearance(font, size, color)
<dd>Get/Set the default text appearance used for free text annotations.
<dt>PDFAnnotation#hasInteriorColor(), #getInteriorColor(), #setInteriorColor(color)
<dd>Check for support/get/set the annotation interior color, represented as an array of up to 4 component values.
<dt>PDFAnnotation#hasAuthor(), #getAuthor(), #setAuthor(author)
<dd>Check for support/get/set the annotation author.
<dt>PDFAnnotation#hasLineEndingStyles(), #getLineEndingStyles(), #setLineEndingStyles(start, end)
<dd>Check for support/get/set the annotation line ending styles, either of "None", "Square", "Circle", "Diamond", "OpenArrow", "ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow" or "Slash".
<dt>PDFAnnotation#hasIcon(), #getIcon(), #setIcon(iconname)
<dd>Check for support/get/set annotation icon. Standard icons names for:
<dl>
<dt>File attachment annotations:
<dd>"Graph", "PaperClip", "PushPin" and "Tag".
<dt>Sound annotations:
<dd>"Mic" and "Speaker".
<dt>Stamp annotations:
<dd>"Approved", "AsIs", "Confidential", "Departmental", "Draft", "Experimental", "Expired", "Final", "ForComment", "ForPublicRelease", "NotApproved", "NorForPublicRelease", "Sold" and "TopSecret".
<dt>Text annotations:
<dd>"Comment", "Help", "Insert", "Key", "NewParagraph", "Note" and "Paragraph".
</dl>
<dt>PDFAnnotation#hasLine(), #getLine(), #setLine(endpoints)
<dd>Check for support/get/set line end points, represented by an array of to points, each represented as an [x, y] array.
<dt>PDFAnnotation#hasOpen(), #isOpen(), #setIsOpen(state)
<dd>Check for support/get/set annotation open state, represented as a boolean.
<dt>PDFAnnotation#hasFilespec(), #getFilespec(), #setFilespec(filespecObject)
<dd>Check for support/get/set annotation file specification, represented by a PDF object.
</dl>

<p>
The border drawn around some annotation can be controlled by:

<dl>
<dt>PDFAnnotation#hasBorder(), #getBorderStyle(), #setBorderStyle(style)
<dd>Check for support/get/set the annotation border style, either of "Solid" or "Dashed".
<dt>PDFAnnotation#getBorderWidth(), #setBorderWidth(width)
<dd>Get/set the border width in points. Retain any existing border effects.
<dt>PDFAnnotation#getBorderDashCount()
<dd>Returns the number of items in the border dash pattern.
<dt>PDFAnnotation#getBorderDashItem(i)
<dd>Returns the length of dash pattern item i.
<dt>PDFAnnotation#setBorderDashPattern(dashpattern)
<dd>Set the annotation border dash pattern to the given array of dash item lengths.
<dt>PDFAnnotation#clearBorderDash()
<dd>Clear the entire border dash pattern for an annotation.
<dt>PDFAnnotation#addBorderDashItem(length)
<dd>Append an item (of the given length) to the end of the border dash pattern.
</dl>

<p>
Annotations that have a border effect allows the effect to be controlled by:

<dl>
<dt>PDFAnnotation#hasBorderEffect(), #getBorderEffect(), #setBorderEffect(effect)
<dd>Check for support/get/set the annotation border effect, either of "None" or "Cloudy".
<dt>PDFAnnotation#getBorderEffectIntensity(), #setBorderEffectIntensity(intensity)
<dd>Get/set the annotation border effect intensity. Recommended values are between 0 and 2 inclusive.
</dl>

<p>
Ink annotations consist of a number of strokes, each consisting of a sequence of vertices between which a smooth line will be drawn. These can be controlled by:

<dl>
<dt>PDFAnnotation#hasInkList(), #getInkList(), #setInkList(inkList)
<dd>Check for support/get/set the annotation ink list, represented as an array of strokes, each an array of points each an array of its X/Y coordinates.
<dt>PDFAnnotation#clearInkList()
<dd>Clear the list of ink strokes for the annotation.
<dt>PDFAnnotation#addInkList(stroke)
<dd>To the list of strokes, append a stroke, represented as an array of vertices each an array of its X/Y coordinates.
<dt>PDFAnnotation#addInkListStroke()
<dd>Add a new empty stroke to the ink annotation.
<dt>PDFAnnotation#addInkListStrokeVertex(vertex)
<dd>Append a vertex to end of the last stroke in the ink annotation. The vertex is an array of its X/Y coordinates.
</dl>

<p>
Text markup and redaction annotations consist of a set of quadadrilaterals controlled by:

<dl>
<dt>PDFAnnotation#hasQuadPoints(), #getQuadPoints(), #setQuadPoints(quadPoints)
<dd>Check for support/get/set the annotation quadpoints, describing the areas affected by text markup annotations and link annotations.
<dt>PDFAnnotation#clearQuadPoints()
<dd>Clear the list of quad points for the annotation.
<dt>PDFAnnotation#addQuadPoint(quadpoint)
<dd>Append a single quad point as an array of 8 elements, where each pair are the X/Y coordinates of a corner of the quad.
</dl>

<p>
Polygon and polyline annotations consist of a sequence of vertices with a straight line between them. Those can be controlled by:

<dl>
<dt>PDFAnnotation#hasVertices(), #getVertices(), #setVertices(vertices)
<dd>Check for support/get/set the annotation vertices, represented as an array of vertices each an array of its X/Y coordinates.
<dt>PDFAnnotation#clearVertices()
<dd>Clear the list of vertices for the annotation.
<dt>PDFAnnotation#addVertex(vertex)
<dd>Append a single vertex as an array of its X/Y coordinates.
</dl>

<p>
Stamp annotations have the option to set a custom image as its appearance.

<dl>
<dt>PDFAnnotation#setStampImage(image)
<dd>Set a custom image appearance for a stamp annotation.
</dl>

<h3>
PDF Widgets
</h3>

<dl>
<dt>PDFPage#getWidgets()
<dd>Return array of all widgets on the page.
<dt>PDFWidget#getFieldType()
<dd>Return string indicating type of widget: "button", "checkbox", "combobox", "listbox", "radiobutton", "signature" or "text".
<dt>PDFWidget#getFieldFlags()
<dd>Return the field flags. Refer to the PDF specification for their meanings.
<dt>PDFWidget#getRect(), #setRect(rect)
<dd>Get/set the widget bounding box.
<dt>PDFWidget#getMaxLen()
<dd>Get maximum allowed length of the string value.
<dt>PDFWidget#getValue(), #setTextValue(value), #setChoiceValue(value)
<dd>Get/set the widget string value.
<dt>PDFWidget#toggle()
<dd>Toggle the state of the widget, returns 1 if the state changed.
<dt>PDFWidget#getOptions()
<dd>Returns an array with one text string describing the state of each kid of radio button/checkbox field.
<dt>PDFWidget#layoutTextWidget()
<dd>Layout the value of a text widget. Returns a TextLayout object described below.
<dt>PDFWidget#isReadOnly()
<dd>If the value is readonly and the widget cannot be interacted with.
<dt>PDFWidget#getLabel()
<dd>Get the field name as a string.
<dt>PDFWidget#getEditingState(), #setEditingState()
<dd>Get/set whether the widget is in editing state. When in editing state any changes to the widget value will not cause any side-effects such as changing other widgets or running javascript. This is intended for e.g. when a text widget is interactively having characters typed into it. Once editing is finished the state should reverted back, before updating the widget value again.
<dt>PDFWidget#update()
<dd>Update the appearance stream to account for changes to the widget.
</dl>

<dl>
<dt>PDFWidget#isSigned()
<dd>Returns true if the signature is signed.
<dt>PDFWidget#validateSignature()
<dd>Returns number of updates ago when signature became invalid. Returns 0 is signature is still valid, 1 if it became invalid during the last save, etc.
<dt>PDFWidget#checkCertificate()
<dd>Returns "OK" if signature checked out OK, otherwise a text string containing an error message, e.g. "Self-signed certificate." or "Signature invalidated by change to document.", etc.
<dt>PDFWidget#getSignatory()
<dd>Returns a text string with the distinguished name from a signed signature, or a text string with an error message.
<dt>PDFWidget#previewSignature(signer, signatureConfig, image, reason, location)
<dd>Return a Pixmap preview of what the signature would look like if signed with the given configuration. Reason and location may be undefined, in which case they are not shown. The signature configuration is described below.
<dt>PDFWidget#sign(signer, signatureConfig, image, reason, location)
<dd>Sign the signature with the given configuration. Reason and location may be undefined, in which case they are not shown. The signature configuration is described below.
<dt>PDFWidget#clearSignature()
<dd>Clear a signed signature, making it unsigned again.
</dl>

<dl>
<dt>new PDFPKCS7Signer(filename, password)
<dd>Read a certificate and private key from a pfx file and create a signer to hold this information. Used with PDFWidget#sign().
</dl>

<p>
A signature configuration of what to include in the signature appearance:
<dl>
<dt>showLabels:
<dd>Whether to include both labels and values or just values on the right hand side.
<dt>showDN:
<dd>Whether to include the distinguished name on the right hand side.
<dt>showTextName:
<dd>Whether to include the name of the signatory on the right hand side.
<dt>showDate:
<dd>Whether to include the date of signing on the right hand side.
<dt>showGraphicName:
<dd>Whether to include the signatory name on the left hand side.
<dt>showLogo:
<dd>Whether to include the MuPDF logo in the background.
</dl>

<dl>
<dt>PDFWidget#eventEnter()
<dd>Trigger the event when the pointing device enter a widget's active area.
<dt>PDFWidget#eventExit()
<dd>Trigger the event when the pointing device exits a widget's active area.
<dt>PDFWidget#eventDown()
<dd>Trigger the event when the pointing device's button is depressed within a widget's active area.
<dt>PDFWidget#eventUp()
<dd>Trigger the event when the pointing device's button is released within a widget's active area.
<dt>PDFWidget#eventFocus()
<dd>Trigger the event when the a widget gains input focus.
<dt>PDFWidget#eventBlur()
<dd>Trigger the event when the a widget loses input focus.
</dl>

<p>
A description of layouted text value from a text widget with keys:
<dl>
<dt>TextLayout.matrix:
<dt>TextLayout.invMatrix:
<dd>Normal and inverted transform matrices for the layouted text.
<dt>TextLayout.lines:
<dd>An array of text lines belonging to the layouted text:
<dl>
<dt>lines.x:
<dt>lines.y:
<dd>The coordinate for the text line.
<dt>lines.fontSize:
<dd>The text size used for the layouted text line.
<dt>lines.index:
<dd>The index of the beginning of the line in the text string.
<dt>lines.rect:
<dd>The bounding rectangle for the text line.
<dt>lines.chars:
<dd>An array of characters in the text line:
<dl>
<dt>chars.x:
<dt>chars.advance:
<dd>The position and advance of the character.
<dt>chars.index:
<dd>The index of the character in the text string.
<dt>chars.rect:
<dd>The bounding rectangle for the character.
</dl>
</dl>
</dl>

<dl>
<dt>new Archive(path)
<dd>Create a new archive based either on a tar- or zip-file or the contents of a directory.
<dt>Archive#getFormat()
<dd>Returns a string describing the archive format.
<dt>Archive#countEntries()
<dd>Returns the number of entries in the archive.
<dt>Archive#listEntry(idx)
<dd>Returns the name of entry number idx in the archive.
<dt>Archive#hasEntry(name)
<dd>Returns true if an entry of the given name exists in the archive.
<dt>Archive#readEntry(name)
<dd>Returns the contents of the entry of the given name.
</dl>

<dl>
<dt>new MultiArchive()
<dd>Create a new empty multi archive.
<dt>MultiArchive#mountArchive(subArchive, path)
<dd>Add an archive to the set of archives handled by a multi archive. If path is null, the subArchive contents appear at the top-level, otherwise they will appear prefixed by the string path.
</dl>

<dl>
<dt>new TreeArchive()
<dd>Create a new empty tree archive.
<dt>TreeArchive#add(name, buffer)
<dd>Add a named buffer to a tree archive.
</dl>

<h3>
Story
</h3>

<dl>
<dt>new Story(contents, user_css, em, archive)
<dd>Create a new story with the given contents, formatted according to the provided user css and em size, and an archive to lookup images, etc.
<dt>Story#document()
<dd>Return a DOM for an unplaced story. This allows adding content before placing the story.
<dt>Story#place(rect)
<dd>Place (or continue placing) a story into the supplied rectangle, returning a PlacementResult described below. Call Story#draw() to draw the placed content before calling Story#place() again to continue placing remaining content.
<dt>Story#draw(device, matrix)
<dd>Draw the placed story to the given device with the given transform.
</dl>

<dl>
<dt>PlacementResult.filled:
<dd>The rectangle of the actual area that was used.
<dt>PlacementResult.more:
<dd>True if more content remains to be placed, otherwise false if all content fit in the story.
</dl>

<h3>
DOM
</h3>

<dl>
<dt>DOM#body()
<dd>Return a DOM for the body element.
<dt>DOM#documentElement()
<dd>Return a DOM for the top level element.
<dt>DOM#createElement(tag)
<dd>Create an element with the given tag type, but do not link it into the DOM yet.
<dt>DOM#createTextMode(text)
<dd>Create a text node with the given text contents, but do not link it into the DOM yet.
<dt>DOM#find(tag, attribute, value)
<dd>Find the element matching the tag, attribute and value. Set either of those to null to match anything.
<dt>DOM#findNext(tag, attribute, value)
<dd>Find the next element matching the tag, attribute and value. Set either of those to null to match anything.
<dt>DOM#appendChild(dom, childdom)
<dd>Insert an element as the last child of a parent, unlinking the child from its current position if required.
<dt>DOM#insertBefore(dom, elementDom)
<dd>Insert an element before this element, unlinking the new element from its current position if required.
<dt>DOM#insertAfter(dom, elementDom)
<dd>Insert an element after this element, unlinking the new element from its current position if required.
<dt>DOM#remove()
<dd>Remove an element from the DOM. The element can be added back elsewhere if required.
<dt>DOM#clone()
<dd>Clone an element (and its children). The clone is not yet linked into the DOM.
<dt>DOM#firstChild()
<dd>Return the first child of the element as a DOM, or null if no child exist.
<dt>DOM#parent()
<dd>Return the parent of the element as a DOM, or null if no parent exists.
<dt>DOM#next()
<dd>Return the next element as a DOM, or null if no such element exists.
<dt>DOM#previous()
<dd>Return the previous element as a DOM, or null if no such element exists.
<dt>DOM#addAttribute(attribute, value)
<dd>Add attribute with the given value, returns the updated element as a DOM.
<dt>DOM#removeAttribute(attribute)
<dd>Remove the specified attribute from the element.
<dt>DOM#attribute(attribute)
<dd>Return the element's attribute value as a string, or null if no such attribute exists.
<dt>DOM#getAttributes()
<dd>Returns a dictionary object with properties and their values corresponding to the element's attributes and their values.
</dl>

<h2>
TODO
</h2>

<p>
There are areas in MuPDF that still need bindings to access from JavaScript:

<ul>
<li>Shadings
</ul>

</article>

<footer>
<a href="http://www.artifex.com/"><img src="artifex-logo.png" align="right"></a>
Copyright &copy; 2006-2023 Artifex Software Inc.
</footer>

</body>
</html>
